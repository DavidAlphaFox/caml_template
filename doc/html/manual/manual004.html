<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="manual.css">
<TITLE>
Programming with the CamlTemplate Library
</TITLE>
</HEAD>
<BODY >
<A HREF="manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H2 CLASS="section"><A NAME="htoc45">4</A>&nbsp;&nbsp;Programming with the CamlTemplate Library</H2>
<A NAME="sec-library"></A>
When reading this section, you will probably find it helpful to refer to the CamlTemplate
API documentation, which is generated by ocamldoc and provided in the <TT>doc/api</TT>
directory of the CamlTemplate distribution.<BR>
<BR>
<A NAME="toc24"></A>
<H3 CLASS="subsection"><A NAME="htoc46">4.1</A>&nbsp;&nbsp;The General Procedure</H3>
The general procedure is as follows:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Create a template cache using <TT>Cache.create</TT>.
<LI CLASS="li-enumerate">Create a data model consisting of values of type <TT>Model.tvalue</TT>.
<LI CLASS="li-enumerate">Load a template using <TT>Cache.get_template</TT>.
<LI CLASS="li-enumerate">Pass the template to the <TT>merge</TT> function to generate output.
</OL>
Here is `Hello, world!' with a template. The template is as follows:
<PRE CLASS="verbatim">
Here is the message: ${message}
</PRE>
And here is a program that uses it:
<PRE CLASS="verbatim">
open Printf ;;
open CamlTemplate.Model ;;

let _ =
  (* Make a template cache. *)
  let cache = CamlTemplate.Cache.create () in
    (* Create a model. *)
  let model = Hashtbl.create 4 in
    Hashtbl.add model "message"
      (Tstr "Hello, world!");    
    try
      (* Get the template. *)
      let tmpl =
        CamlTemplate.Cache.get_template
          cache "hello.tmpl"
          (* Make a buffer for the output. *)
      and buf = Buffer.create 256 in
        (* Generate output. *)
        CamlTemplate.merge tmpl model buf;
        print_string (Buffer.contents buf)
    with
        CamlTemplate.Syntax_error msg -&gt;
          eprintf "\n%s\n" msg
      | CamlTemplate.Template_error msg -&gt;
          eprintf "\n%s\n" msg ;;
</PRE>
There are other examples in the <TT>examples</TT> directory of the distribution.<BR>
<BR>
<A NAME="toc25"></A>
<H3 CLASS="subsection"><A NAME="htoc47">4.2</A>&nbsp;&nbsp;Template Data Models</H3>
A template data model is a tree of values; these values can be scalars (strings, integers,
floats or booleans), lists, hashtables or functions. The root of the tree must be a
hashtable. In a template, an identifier by itself is the name of an entry in that root
hashtable.<BR>
<BR>
Tabular data can be represented as a list of hashes of scalars. Each element in the list
represents a row in the table, and consists of a hash in which the names are column names
and the values are cell values. Such a model can be handled as shown in
Section&nbsp;<A HREF="manual002.html#example-table">2.3</A>.<BR>
<BR>
<A NAME="toc26"></A>
<H3 CLASS="subsection"><A NAME="htoc48">4.3</A>&nbsp;&nbsp;Loading and Caching Templates</H3>
Once loaded and parsed, templates are cached; the <TT>Cache</TT> module provides functions
for creating template caches, getting templates from them and configuring the behaviour of
a cache (e.g. how often it is refreshed). By default, templates are loaded from files,
but you can provide a class of type <TT>source_loader</TT> to load them from another
source.<BR>
<BR>
The <TT>#include</TT> and <TT>#open</TT> statements fetch the included or opened template from
the cache when the enclosing template is merged. Therefore, if an <TT>#include</TT> or <TT>#open</TT> refers to a template that doesn't exist, this won't be detected until the outer
template is merged.<BR>
<BR>
Macros are stored in the templates in which they are defined. When a template containing
a macro definition changes, the macro definition is updated as well.<BR>
<BR>
<A NAME="toc27"></A>
<H3 CLASS="subsection"><A NAME="htoc49">4.4</A>&nbsp;&nbsp;Threads</H3>
<A NAME="sec-manual-threads"></A>
CamlTemplate provides optional support for multithreaded programs. If you need thread
 support, in addition to linking your program with the <TT>camlTemplate</TT> library, you
 must also link in <TT>camlTemplate_mt.cmo</TT> (for bytecode programs) or <TT>camlTemplate_mt.cmx</TT> (for native-code programs). This ensures that the following are
 true:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Multiple threads can safely use the same template cache concurrently.<BR>
<BR>
<LI CLASS="li-itemize">Multiple threads can safely pass the same template (or different templates) to the
 <TT>merge</TT> function.<BR>
<BR>
<LI CLASS="li-itemize">Multiple templates running in different threads can safely use the same model, as
long as no template function changes the model. (Note that none of the template
statements, including <TT>#set</TT> and <TT>#var</TT>, can change the model.) Values set
using <TT>#set</TT> and <TT>#var</TT> are visible only to the thread that set them.
</UL>
<A NAME="toc28"></A>
<H3 CLASS="subsection"><A NAME="htoc50">4.5</A>&nbsp;&nbsp;Error Handling</H3>
The <TT>get_template</TT> function raises <TT>Syntax_error</TT> if it cannot parse a template.
It may also raise other exceptions if it fails to read template source code because of an
I/O error.<BR>
<BR>
If a template cannot be merged because of a run-time error (e.g. a wrong data type), the
<TT>merge</TT> function raises <TT>Template_error</TT>.<BR>
<BR>
If a Caml function called from a template is unable to complete successfully, it can raise
<TT>Tfun_error</TT>; this causes <TT>merge</TT> to raise <TT>Template_error</TT>.<BR>
<BR>
<HR>
<A HREF="manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
